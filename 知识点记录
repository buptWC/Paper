# 操作系统：
## 第一部分：进程
q1: 作业、进程、线程、管程的定义？
a1: 作业是用户在处理一次事务过程中要求计算机系统所做工作的集合（包括用户程序、数据、命令等），作业是一系列有序的动作构成的。
    进程是一个程序在一个数据集合上的运行过程。（即使是同一个程序在同一个数据集合上多次运行，都属于不同的进程！）
    线程是进程的一个实体，是被系统独立调度和执行的基本单位。
    管程是定义了一个数据结构和一组操作（能为并发进程所执行），这组操作能同步进程和改变管程中的数据。

q2: 进程间的通信如何实现？
a2: 进程间通信（Interprocess communication, IPC）是一组编程接口，让不同的进程能在一个操作系统中同时运行并相互传递、交换信息。
    IPC方法包括 管道(PIPE)，消息队列，共享内存以及套接字(Socket)。
    管道中又分为普通管道（单工，只能单向传输），流管道（半双工，可以双向传输）。普通管道通常只能在亲子关系间的进程间使用，命名管道没有这个限制。
    消息队列可以被多个进程所共享，一个消息队列放不下可以用多个消息队列。

q3: 什么是死锁，死锁发生的条件是什么？如何预防死锁？
a3: 死锁是指两个或以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象。
    死锁发生的必要条件包括4点，缺一不可：
    1）互斥条件，一个资源每次只能被一个进程使用。
    2）请求与保持条件，一个进程因请求资源而阻塞时，对已持有的资源保持不放。
    3）不剥夺条件，进程已获得的资源，在未使用完之前，不可被剥夺。
    4）循环等待条件，若干进程之间形成一种头尾相接的循环等待资源关系。
    预防死锁的措施包括3点（因为无法破坏互斥条件）：
    1）采用资源静态分配策略，破坏“部分分配”条件
    2）允许进程剥夺使用其他进程占有的资源，即破坏上述条件3
    3）采用资源有序分配法，破坏“环路”条件

q4: 进程的三种基本状态？
a4: 1）就绪态（Ready），当进程分配到除CPU以外的所有必要的资源时，此时称为就绪态
    2）执行态（Running），当进程正在处理机上进行，此时称为执行态
    3）阻塞态（Blocked），“正在执行”的进程，由于等待某个事件发生而无法执行时，此时称为阻塞态

q5: 进程上下文，线程上下文？
a5: 当一个进程从内核中移出，另一个进程成为活动的，这些进程之间便发生了上下文切换。
    进程的上下文信息包括：
    进程id,指向可执行文件的指针，栈，静态和动态分配的变量的内存，状态，优先级，处理器寄存器。
    线程的上下文信息包括：
    栈，状态，优先级，寄存器

## 第二部分：线程
q1: 进程和线程的差别？
a1: 进程是程序的一次执行，线程可以理解为进程中执行的一段程序片段。
    同一进程中的两端代码不能够同时执行，除非引入线程。
    线程是属于进程的，当进程退出时该进程所产生的线程都会被强制退出并清除。
    进程间可以通过IPC通信，但线程不可以。
    进程切换代价大，线程切换代价小，同一进程的线程可以共享进程的资源，但不同进程之间不能共享资源。

q2: 为什么要引入线程？
a2: 虽然进程可以提高cpu的利用率，但进程同一时间只能做一件事，并且进程间的切换非常耗费资源和时间，为了进一步提升操作系统的并发性，引入了线程。
    一个进程内部的线程可以共享进程所分配到的资源，且线程的创建和切换消耗资源远小于进程。

## 第三部分：内存管理
q1: windows系统内存管理有几种方式，优缺点是什么？  
a1: 内存管理方式主要分为：页式管理、段式管理、段页式管理。  
    页式管理的基本原理是将进程的虚拟空间划分为若干个长度相等的页(page)；然后将内存空间也按页的大小划分成若干个页，最后建立虚拟地址与内存地址一一对应的页表  。  
    优点：没有外碎片，每个内碎片的大小不超过页的大小。  
    缺点：程序全部装入内存，要求有响应的硬件支持。  
    
    段式管理的基本原理是将程序按内容划分成段，每段有自己的名字。通过地址影射将段式虚拟地址转换成实际内存物理地址。  
    优点：可以分别编写和编译，可以针对不同的段采取不同的保护，可以按段为单位进行共享。  
    缺点：产生碎片。  
    
    段页式管理的基本原理是先将程序划分成段（建立段表），然后对每个段又划分成若干页，每个段都需要建立页表，将段中的虚页变成内存中的实际页面。  
    优点：集成了上述两者的优点  
    缺点：复杂性增加，开销变大，执行速度下降。  
     
q2: 操作系统的四个特征是什么？
a2: 并发、共享、虚拟和异步，最主要的特征是并发。
    并发指两个或多个事件在同一时间间隔内发生。（微观上这些时间是在分时地交替执行，这是通过分时得以实现）
    共享指系统中资源可以被多个并发执行的程序共同使用，而不是被独占，包括互斥访问和同时访问。
    异步指在多个程序并发执行时，由于资源有限，进场的执行可能会走走停停，但保证最后的结果不会出错（若结果和时间有关可能会出现出错）。
    虚拟指把物理的一个实体变成逻辑上的多个对应物，或把物理上的多个实体变成逻辑上的一个对应物的技术。

q3: 分时系统的四个特征是什么？
a3: 多路性、交互性、独占性、及时性
    多路性指有多个用户使用一台计算机，宏观上是多个人同时使用一个CPU，微观上是多个人在不同时刻轮流使用。
    交互性指用户根据系统响应结果进一步提出新请求（用户直接干预每一步）
    独占性指用户感觉不到计算机为其他人服务，仿佛整个系统他独占。
    及时性指系统对用户的请求及时响应。

## 第四部分：其他内容
q1: 什么是自旋锁，与互斥锁的区别？
a1: 和互斥锁一样是为实现保护共享资源而提出的一种锁的机制。无论是互斥锁还是自旋锁，都保证在同一时间只能有一个保持者。
    但对于互斥锁来说，如果资源已经被占用，申请者只能进入睡眠状态，等待资源释放后再苏醒。
    而对于自旋锁来说，如果资源以及被占用，申请者会一直循环等待，等待资源释放。
    优势：自旋锁适用于锁使用者使用时间比较短的情况，这样效率远高于互斥锁，可以在任何上下文中使用（信号量和互斥锁只能在进程上下文使用）。
    劣势：可能会造成死锁。（递归地获得自旋锁必然会引起死锁）
         过多占用cpu资源，导致性能降低。（通常设定一个参数限定最多持续尝试次数，超过后则放弃当前time slice）
 
q2: 缺页中断以及页面置换算法
a2: 判断所访问的页面是否存在于内存中，若不在则发生一次缺页中断，发生缺页中断时需要经过4个处理步骤：
    1. 保护cpu现场；2.分析中断原因；3.转入缺页中断处理程序进行处理；4.恢复cpu现场，继续执行。
    应对缺页中断，需要用到页面置换算法，常用的页面置换算法包括：
    1. OPT最佳置换：理想情况下的方法，通常用来衡量其他页面置换算法。将未来用不到的或者最少用到的换出去。
    2. FIFO先进先出：将最先进入内存的页面最先置换出去，缺点很大，目前很少使用。
    3. LRU：将最佳一段时间最长时间没访问过的页面置换出去。开销较大，需要硬件支持。
    4. CLOCK：给每页置一个使用位，最近被使用过就置1，置换第一个是0的页面。

q3: 哲学家进餐问题解决方案？
a3: 方法1： 只有当哲学家两侧的筷子都可用时，才允许他拿起筷子进餐  
    方法2： 至多只允许n-1个人拿起左边筷子  
    方法3： 奇数号的哲学家先拿左边的筷子再拿右边的筷子，偶数号的哲学家相反。

q4: 读写锁？
a4: 读写锁允许多个读者同时读，但同一时间只能有一个写者写（写的时候不能有人读），并且写者优先级大于读者，一旦有写者，后续读者需等待  
    且在唤醒时也是优先唤醒写者

q5: 用户态切换到内核态？
a5: 系统调用、异常，外围设备中断。

# 数据库
## 第一部分：数据库理论
q1: 什么是数据库事务？
a1: 数据库事务是指作为单个逻辑工作单元执行的一系列操作，这些操作要么全做要么全不做，是一个不可分割的工作单位。
    事务具有原子性、一致性、独立性、持久性。
    原子性：事务要么全部执行，要么全部不执行。出错则回滚到未执行的状态。例如从银行取钱，分为2步，1）从存折扣钱；2）拿到钱。不可能只扣钱没拿到钱。
    一致性：事务的运行不改变数据库的一致性。如有约束条件a+b=10，若a变动，则b也要变动。
    独立性：两个以上的事务不会出现交错执行的状态。
    持久性：事务运行成功后，就系统的更新是永久的，不会无缘无故的回滚。

q2: 触发器分为事前触发和事后触发，这两种触发有何区别？语句级触发和行级触发有何区别？
a2: 事前触发器运行于触发事件发生之前，事后触发运行于触发时间发生之后。
    语句级触发可以在语句前或语句后触发，行级触发在触发器影响的每一行都触发一次。

q3: 聚集索引和非聚集索引有何区别？
a3: 聚集索引的顺序就是数据的物理存储顺序，非聚集索引的索引顺序与数据物理排列顺序无关，所以一个表中最多只能有一个聚集索引。

q4: 数据库的三大范式？
a4: 第一范式：每一列都是不可分割的基本项，同一列中不能有多个值。
    第二范式：在第一范式的基础上，每个非主键属性完全依赖于主键属性。
    第三范式：在第二范式的基础上，不存在非主键属性传递依赖于主键属性。
    BC范式：在第三范式的基础上，只有一个候选键，并且候选键是单属性。

q5: 数据库索引？
a5: 索引的目的是加快数据库的查询速度。分为聚集索引和非聚集索引。
    唯一索引是不允许任何两行具有相同索引值的索引。如在name上创建了唯一索引，那么不能存在相同name的人。
    主键索引：一列或多列组合，唯一标识表中的每一行。
    聚集索引：键值的逻辑顺序就是数据在内存中的物理顺序，通常选自增键作为聚集索引。

q6: 数据库事务不隔离可能产生？
a6: 1.脏读（dirty read）。指一个事务处理过程里读取了另一个未提交的事务中的数据。  
    2.不可重复读。指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。  
    3.幻读。指一个事务多次查询却获得了不同结果。xxxxx（这个和第二点感觉差别不是很大）

q7: k-v存储中，key有哪些要求?
a7: 

q8: 数据库中的WAL技术
a8: Write Ahead Logging，是数据库实现原子事务的一种机制。

## 第二部分：数据库代码
q1: 选择表中的一列或多列数据
a1: select c1,c2,... from table

q2: 删除表中某列数据
a2: delete c1,c2,... from table

q3: 需要删除重复数据
a3: select distinct c1 from table

q4: 日期的转换
a4: TO_DAYS(DATE)可以转成int型，相差几天可以通过减法计算

q5: 多表联合处理？
a5: 每个表必须有一个别名

q6: 取前n条数据
a6: select * from table limit n
    mysql 中没有top方法，limit可以接受两个参数，如limit 5,10 表示第6条到第15条数据

q7: 取某个出现过n次以上的值
a7: select col from table group by col having(count(col) > n)

## 第三部分：其他内容
q1: 什么是主从复制，主从复制的好处是什么？
a1: 主从复制是用来建立一个和主数据库完全一样的数据库环境，称为从数据库。主数据库一般是准实时的业务数据库。
    好处包括：
    1. 做数据的热备，作为后备数据库，当主数据库服务器故障后，可切换到从数据库继续工作，避免数据丢失。
    2. 架构的扩展。业务量变大后，i/o访问频率过高，单机无法满足，此时做多库的存储，降低了I/O访问频率。
    3. 读写分离，使数据库能支撑更大的并发

q2: 主从复制的原理？
a2: 数据库有一个bin-log二进制文件，记录了所有的sql语句。我们的目标就是把主数据库的bin-log文件中的sql语句复制过来在从数据库重新执行一遍。
    具体需要三个线程来操作：
    1. bin-log输出线程。由主库创建，用以发送bin-log文件至从数据库。
    2. I/O线程。由从库创建，该线程连接到主库并请求主库发送bin-log里面的更新记录。
    3. SQL线程。由从库创建，读取I/O线程获得的更新事件并执行。
    
q3: 数据完整性约束是什么？具体包括？
a3: 数据完整性约束指的是为了防止不符合规范的数据进入数据库，在用户对数据进行增删改查的时候，系统按照一定的约束条件对数据进行监测。
    包括实体完整性、参照完整性、用户定义完整性。
    实体完整性在mysql中通过主键约束和候选键约束实现。
    主键是表中的若干列的组合。一个表只能有一个主键，主键的值在一张表里面不能重复，且不能为空。满足最小化原则，也就是删去一个参数之后不能还是可以作为主键。
    候选键指某一列可以唯一标识一张表，且不包含多余的属性，那么这就是一个候选键。如学生的学号。不能为空， 且唯一。
    
    参照完整性通过外键约束实现。关系中的外键必须是另一个关系的主键有效值，或者是空。

q4: mysql的四种隔离状态?
a4: 读未提交（Read Uncommitted）、读提交（Read Committed）、可重复读（Repeated Read）、串行化（Serializable）。
    读未提交：表示可以读到其他事物未提交的内容。这种无法消除任何一种状况。
    读提交：只能读到已提交的内容。可以消除脏读。是sql server 和 oracle的默认隔离级别。
    可重复读：当开始读时就不允许进行修改操作了。可以消除不可重复读、脏读。是mysql的默认隔离级别。
    串行化：事物一个个进行，是最高级别，可以消除全部状况，但效率极差，性能开销大，没人用。

q5: mysql的mvcc机制

q6: sql优化方法有哪些？

q7: mysql引擎和区别？
a7: innodb和myisam。
    Innodb引擎提供了对数据库ACID事务的支持，并实现了4种隔离级别。提供行级锁和外键约束，目的是处理大容量数据库系统。
    MyISAM是MySQL的默认引擎，但没有提供对数据库事务的支持，也不支持行级锁和外键，当insert和update时需要锁定整张表，效率慢一点。
    区别：
    1. MyISAM是非事务安全的，InnoDB是事务安全的。
    2. MYISAM锁的粒度是表极的，Innodb支持行级锁。
    3. MYISAM支持全文类型索引，而InnoDB不支持全文索引。
    4. MYISAM相对简单，对于小型应用可以效率优于InnoDB.
    5. MyISAM表保存为文件形式，跨平台使用更加方便。

# 数据结构
## B树
q1: m阶B树的性质
a1: m阶B树的性质包括：
    1. 树中每个结点最多含有m个孩子（m>=2）
    2. 除根结点和叶子结点外，每个结点至少有ceil(m/2)个孩子
    3. 若根结点不是叶子结点，则至少有2个孩子
    4. 所有叶子结点出现在同一层
    5. 每个非终端结点中包含n个关键字信息：（p0, k1, p1, k2, p2, ..., kn, pn），也就是说，有j个孩子的非叶结点恰好有j-1个关键字。
    其中ki表示关键字，且升序排列，pi指向子节点，且pi-1指向的子树中的所有结点的关键字均小于ki，且大于ki-1。n的个数必须满足ceil(m/2)-1 <= n <= m-1

## 红黑树
q1: 红黑树的性质
a1: 1. 每个结点要么是红的，要么是黑的
    2. 根结点是黑的
    3. 每个叶结点是黑的
    4. 对任一结点而言，其到叶结点树尾端NIL指针的每一条路径都包含相同数目的黑结点。

q2: 红黑树相比于BST和AVL树有什么优点？
a2: 红黑树牺牲了严格的高度平衡，只打到部分平衡要求，从而提高性能，搜索、插入、删除最坏以O(LOG2N)的时间复杂度完成。
    相比于BST，红黑树保证树中最长路径不大于最短路径的两倍

# 计算机网络
## 其他部分
q1: A,B,C类地址
a1: A类：1.0.0.0 - 127.255.255.255， 子网掩码 255.0.0.0
    B类：128.0.0.0 - 191.255.255.255， 子网掩码 255.255.0.0
    C类：192.0.0.0 - 223.255.255.255， 子网掩码 255.255.255.0

q2: 虚电路与数据报
a2: 虚电路传输前需建立虚电路，适用于两端长时间的数据交换。
    数据报无需建立链路，在目的地需要重新组装报文。
    虚电路优点：可靠、保持顺序。          缺点：如发生故障，则经过故障点的数据全部丢失。
    数据报优点：如发生故障可绕开故障点。   缺点：不能按序到达，丢失不能立即知晓。

q3: 电路交换、报文交换、分组交换
a3: 电路交换：在通信双方之间建立一条被双方独占的物理通路，然后进行通信。
            优点：链路双方专用，数据直达，故传输时延非常小；通路一旦建立，可以随时通信，实时性强；顺序传输数据；可以传输模拟信号和数字信号。
            缺点：链路建立花费时间长，独占链路故信道利用率低。差错控制不好做。
    报文交换：以报文为数据交换的单位，报文携带有目标地址、源地址等信息，在交换节点采用存储转发的传输方式。
            优点：不需要建立链路，即不存在链接建立时延。可以应对故障、提供多目标服务，即一个报文可以发送到多个目的地址、允许建立数据传输优先级、提升通信线路的利用率。
            缺点：转发时延大，实时性差、只适用于数字信号。
    分组交换：在报文交换的基础上，将长报文先分割为若干个较短的分组，然后把这些分组逐个发送出去（包含虚电路和数据报）。具有报文交换的优点，此外还包含：
            优点：略微减少了传输时延，减少了出错几率和重发数据量，更适用于优先级策略。
            缺点：传输时延仍然较大，每个分组都加上源、目的信息，传送的信息量更大，一定程度降低了通信效率。

q4: tcp三次握手和四次挥手，状态的变化？
a4: 三次握手：
    client向server发送syn包，包含自己的序号a，进入syn-sent状态（同步已发送）
    server收到syn包，发出确认报文，syn=1，ack=a+1，seq=b，进入syn-rcvd状态（同步已接受）
    client收到server的确认包之后，再向server发出确认包ack=b+1,seq=a+1，进入established状态（连接已建立）
    server收到client的确认宝之后，进入established状态，此时可以通信

    四次挥手：
    client主动发出连接释放报文，并停止发送数据，fin=1,seq=u,(u是之前收到的报文的序号+1)，进入fin-wait1状态（终止等待1）.
    server收到连接释放报文，发出确认报文，ACK=1,ack=u+1,seq=v，server进入close-wait状态(关闭等待)，但可能数据还没发送完，所以先把数据发完。
    client收到确认报文后，进入fin-wait2（终止等待2）状态，此时仍在接受数据，等待server的连接释放报文
    server将数据发完之后，发送连接释放报文，ACK=1，ack=u+1，seq=w， server进入last-ack(最后确认)状态
    client收到连接释放报文，发出确认报文。ACK=1,ack=w+1,seq=u+1，进入time-wait(时间等待)状态。注意此时连接还没释放，还需等待一段时间后才可。
    server收到确认报文，立即进入closed状态，过一段时间后，client也进入closed状态。

q5: tcp如何保证可靠传输？
a5: 1. 确认和重传机制。接收方收到报文就会确认，发送方一段时间内没收到确认就会重传。
    2. 数据校验。检验接收到的数据是否正确
    3. 流量控制。当接收方来不及处理发送方的数据时，会让发送方降低发送速率，防止包丢失。
    4. 拥塞控制。当网络拥塞时，减少数据的发送。
    5. 发送的数据有序且合理分片。

q6: tcp拥塞控制的机制？
a6: tcp通过一个定时器采样rtt(往返传输时间)并计算rto(重传超时时间)，如果网络上的延时突然增加，tcp需要重传数据，然而重传会导致网络的负担更重  
    导致更大的延迟以及更多的丢包。tcp的拥塞控制机制就是用于应对这种情况。
    慢开始，拥塞避免，慢启动，快恢复。
    


# linux
## 常用指令
pwd: 查看当前目录


