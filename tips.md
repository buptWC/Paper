给几条算法的小tips吧，虽然每条可能听起来都是理所当然，但要在做题的时候实际意识到还挺难的。

__题目分析：__  
这一条真是显然，不分析肯定做不出来。
但其实关键在于捕捉题目中的关键字样，比如：
1. 求xxxx__最短__距离，赶紧想到bfs。
2. 找一个值，这个值需要满足xxx情况，必是二分。
3. 结果值可能太大，mod 1e9+7，八成是个dp
4. 暴力法分析是发现这道题可以dfs穷举，那么这道题一定是dp

当想到方法之后，就疯狂往这个上面靠就行了，通常不会出错。（特别简单的除外）

__数据范围：__  
这一条仿佛也是显然，但其实很多人并不太会在意。
通常数据范围就是告诉你这道题的复杂度应该是多少，尤其是大公司，能O(n)做出来的题目，他是不可能让你O(n^2)偷过的。但是O(nlogn)是有可能的，logn毕竟太小了，相当于一个大常数的O(n)

数据范围通常有以下这么几种：
1. n<200000，这告诉你，肯定是O(n)，直接往双指针上面想，新开O(n)空间记录相关信息__不一定__可行，也分情况。
2. n<50000，这个和上面的差不多，但是可以先排序或者开O(n)空间再操作。
3. n<10000，10000是分界点，此时恰好不能用O(n^2)的解法，通常和50000的情况差不多
4. n<3000，可以O(n^2)，但是要小心，如果n^2前面的系数有点大也会超时
5. n<1000，这个门道就多了，可能是n,nlogn,n^2的任意一种。(绝大情况下是n^2，否则<1000就没意义了)对于很大一部分情况，那就是定义dp\[i][j]表示数组nums[i:j]或者字符串s[i:j]内的结果，然后找递推式。对于可能是n, nlogn的情况，那就和上面几种没有区别。当然实际情况很多，这里只能说个大概。
6. n<20，这种可能见得比较少，但通常在图问题里面这个范围还挺常见的，那就是位运算，也就是复杂度为2^n，具体怎么用呢，因为图里面通常是遍历问题，所以是用位来记录每个节点的遍历情况，比如`10011`表示访问过了节点0,1,4，(1 << i 这样来计算)

当然还有一些其他的东西  
打个小比方，当你看到一道题的数据范围很大，只能用O(n)（或者题目本身有规定你一定要用n复杂度来解），但这道题又一定要排序或者说二分找值的时候，你可能得想到桶排序(复杂度近似O(n))这种东西。

又比如一个搜索题，你发现n^2搜一次完全ok，但是他让你搜m次，而m*n^2就超时了。
那这个时候肯定是变构造数据结构存信息边搜。
常用的有：二叉搜索树，前缀树，线段树


虽然说了一些，但其实还是靠自己真正做时候的思维，因为很难有个固定模式，所以上面也只是提供一些思路吧（就万一你没想到要怎么做的时候可以跟着这个想一遍，或许有用）。  
PS: 其实题目分析中写的那几个还挺重要的，因为太常见了。
